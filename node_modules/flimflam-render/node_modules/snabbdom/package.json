{
  "name": "snabbdom",
  "version": "0.3.1",
  "description": "A virtual DOM library with focus on simplicity, modularity, powerful features and performance.",
  "main": "snabbdom.js",
  "directories": {
    "example": "examples",
    "test": "test"
  },
  "dependencies": {},
  "devDependencies": {
    "benchmark": "^1.0.0",
    "fake-raf": "0.0.1",
    "knuth-shuffle": "^1.0.1"
  },
  "scripts": {
    "test": "testem"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/paldepind/snabbdom.git"
  },
  "keywords": [
    "virtual",
    "dom",
    "light",
    "kiss",
    "performance"
  ],
  "author": {
    "name": "Simon Friis Vindum"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/paldepind/snabbdom/issues"
  },
  "homepage": "https://github.com/paldepind/snabbdom#readme",
  "readme": "# Snabbdom\n\nA virtual DOM library with focus on simplicity, modularity, powerful features\nand performance.\n\n[![Join the chat at https://gitter.im/paldepind/snabbdom](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/paldepind/snabbdom?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\n## Table of contents\n\n* [Introduction](#introduction)\n* [Features](#features)\n* [Inline example](#inline-example)\n* [Examples](#examples)\n* [Core documentation](#core-documentation)\n* [Modules documentation](#modules-documentation)\n* [Helpers](#helpers)\n\n## Why\n\nVirtual DOM is awesome. It allows us to express our applications view as a\nfunction of its state. But existing solutions were way way too bloated, too\nslow, lacked features, had an API biased towards OOP and/or lacked features I\nneeded.\n\n## Introduction\n\nSnabbdom consists of an extremely simple, performant and extensible core that\nis only ≈ 200 SLOC. It offers a modular architecture with rich functionality\nfor extensions through custom modules. To keep the core simple all non-essential\nfunctionality is delegated to modules.\n\nYou can mold Snabbdom into whatever you desire! Pick, choose and customize the\nfunctionality you want. Alternatively you can just use the default extensions\nand get a virtual DOM library with high performance, small size and all the\nfeatures listed below.\n\n## Features\n\n* Core features\n  * About 200 SLOC – you could easily read through the entire core and fully.\n    understand how it works.\n  * Extendable through modules.\n  * A rich set of hooks available both per vnode and globally for modules.\n    so they can hook into any part of the diff and patch process.\n  * Splendid performance. Snabbdom is among the fastest virtual DOM libraries.\n    in the [Virtual DOM Benchmark](http://vdom-benchmark.github.io/vdom-benchmark/).\n  * Patch function with a function signature equivelant to a reduce/scan.\n    function. Allows for easier integration with a FRP library.\n* Features in modules\n  * `h` function for easily creating virtual DOM nodes.\n  * [SVG _just works_ with the `h` helper](#svg).\n  * Features for doing complex CSS animations.\n  * Powerful event listener functionality.\n  * [Thunks](#thunks) to optimize the diff and patch process even further.\n  * JSX support thanks to [snabbdom-jsx](https://github.com/yelouafi/snabbdom-jsx).\n    There is also a Babel plugin [babel-snabbdom-jsx](https://github.com/finnsson/babel-snabbdom-jsx).\n  * Server-side HTML output provided by [snabbdom-to-html](https://github.com/acstll/snabbdom-to-html).\n\n## Inline example\n\n```javascript\nvar snabbdom = require('snabbdom');\nvar patch = snabbdom.init([ // Init patch function with choosen modules\n  require('snabbdom/modules/class'), // makes it easy to toggle classes\n  require('snabbdom/modules/props'), // for setting properties on DOM elements\n  require('snabbdom/modules/style'), // handles styling on elements with support for animations\n  require('snabbdom/modules/eventlisteners'), // attaches event listeners\n]);\nvar h = require('snabbdom/h'); // helper function for creating VNodes\nvar vnode = h('div#container.two.classes', {on: {click: someFn}}, [\n  h('span', {style: {fontWeight: 'bold'}}, 'This is bold'),\n  ' and this is just normal text',\n  h('a', {props: {href: '/foo'}}, 'I\\'ll take you places!')\n]);\nvar container = document.getElementById('container');\n// Patch into empty DOM element – this modifies the DOM as a side effect\npatch(container, vnode);\nvar newVnode = h('div#container.two.classes', {on: {click: anotherEventHandler}}, [\n  h('span', {style: {fontWeight: 'normal', fontStyle: 'italics'}}, 'This is now italics'),\n  ' and this is still just normal text',\n  h('a', {props: {href: '/bar'}}, 'I\\'ll take you places!')\n]);\n// Second `patch` invocation\npatch(vnode, newVnode); // Snabbdom efficiently updates the old view to the new state\n```\n\n## Examples\n\n* [Animated reordering of elements](http://paldepind.github.io/snabbdom/examples/reorder-animation/)\n* [Hero transitions](http://paldepind.github.io/snabbdom/examples/hero/)\n\n## Core documentation\n\nThe core of Snabbdom provides only the most essential functionality. It is\ndesigned to be as simple as possible while still being fast and extendable.\n\n### `snabbdom.init`\n\nThe core exposes only one single function `snabbdom.init`. `init` takes a list of\nmodules and returns a `patch` function that uses the specified set of modules.\n\n```javascript\nvar patch = snabbdom.init([\n  require('snabbdom/modules/class'),\n  require('snabbdom/modules/style'),\n]);\n```\n\n### `patch`\n\nThe `patch` function returned by `init` takes two arguments. The first is a DOM\nelement or a vnode representing the current view. The second is a vnode\nrepresenting the new updated view.\n\nIf a DOM element with a parent is passed `newVnode` will be turned into a DOM\nnode and the passed element will be replaced by the created DOM node. If an old\nvnode is passed Snabbdom will effeciently modify to match the description in\nthe new vnode.\n\nAny old vnode passed must be the resulting vnode from a previous call to\n`patch`. This is necessary since Snabbdom stores information in the vnode.\nThis makes it possible to implement a simpler and more performant architecture.\nThis also avoids the creation of a new old vnode tree.\n\n```javascript\npatch(oldVnode, newVnode);\n```\n\n### `snabbdom/h`\n\nIt is recommended that you use `snabbdom/h` to create VNodes. `h` accepts a\ntag/selector as a string, an optional data object and an optional string or\narray of children.\n\n```javascript\nvar h = require('snabbdom/h');\nvar vnode = h('div', {style: {color: '#000'}}, [\n  h('h1', 'Headline'),\n  h('p', 'A paragraph'),\n]);\n```\n\n### Hooks\n\nHooks are a way to hook into the lifecycle of DOM nodes. Snabbdom\noffers a rich selection of hooks. Hooks are used both by modules to\nextend Snabbdom and in normal code for executing arbitrary code at\ndesired points in the life of a virtual node.\n\n#### Overview\n\n| Name        | Triggered when                                     | Arguments to callback   |\n| ----------- | --------------                                     | ----------------------- |\n| `pre`       | the patch process begins                           | none                    |\n| `create`    | a DOM element has been created based on a VNode    | `emptyVNode, vnode`     |\n| `insert`    | an element has been inserted into the DOM          | `vnode`                 |\n| `prepatch`  | an element is about to be patched                  | `oldVnode, vnode`       |\n| `update`    | an element is being updated                        | `oldVnode, vnode`       |\n| `postpatch` | an element has been patched                        | `oldVnode, vnode`       |\n| `destroy`   | an element is directly or indirectly begin removed | `vnode`                 |\n| `remove`    | an element is directly being removed from the DOM  | `vnode, removeCallback` |\n| `post`      | the patch process is done                          | none                    |\n\nThe following hooks are available for modules: `pre`, `create`,\n`update`, `destroy`, `remove`, `post`.\n\nThe following hooks are available in the `hook` property of individual\nelements: `create`, `insert`, `prepatch`, `update`, `postpatch`,\n`destroy`, `remove`.\n\n#### Usage\n\nTo use hooks, pass them as an object to `hook` field of the data object\nargument.\n\n```javascript\nh('div.row', {\n  key: movie.rank,\n  hook: {\n    insert: (vnode) => { movie.elmHeight = vnode.elm.offsetHeight; }\n  }\n});\n```\n\n#### The `insert` hook\n\nThis hook is invoked once the DOM element to a vnode has been inserted into the\ndocument _and_ the rest of the patch cycle is done. This means that you can do\nDOM measurements (like using [getBoundingClientRect](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect)\nin this hook safely knowing that no elements will be changed afterwards which\ncould affect the position of the inserted elements.\n\n#### The `remove` hook\n\nAllows you to hook into the removal of an element. The hook is called once a\nvnode is to be removed from the DOM. The handling function recieves both the\nvnode and a callback. You can control and delay the removal with the callback.\nIt should be invoked once the hook is done doing its business and the element\nwill only be removed once all `remove` hooks have invoked their callback.\n\nThe hook is only triggered when and element is to be removed from its parent –\nnot if it is the child of an element that is removed. For that see the destroy\nhook.\n\n#### The `destroy` hook\n\nThis hook is invoked whenever an element removed from the DOM or the child\nto an element that is being removed.\n\n\nTo see the difference between this hook and the `remove` hook consider an\nexample.\n\n```js\nvar vnode1 = h('div', [h('div', [h('span', 'Hello')])]);\nvar vnode2 = h('div', []);\npatch(container, vnode1);\npatch(vnode1, vnode2);\n```\n\nHere `destroy` is triggered for both the inner `div` element _and_ the `span`\nelement it contains. `remove` on the other hand is only triggered on the `div`\nelement because it is the only element being detached from its parent.\n\nYou can for instance use `remove` to trigger an animation when an element is\nbeing removed and use the `destroy` hook to additionally animate the\ndisappearance of the removed elements children.\n\n### Creating modules\n\nModules works by registering global listeners for the [hooks](#hooks). A module as simply a dictionary from hook names to functions.\n\n```javascript\nvar myModule = {\n  create: function(oldVnode, vnode) {\n    // invoked whenever a new virtual node is created\n  },\n  update: function(oldVnode, vnode) {\n    // invoked whenever a virtual node is updated\n  }\n};\n```\n\nWith this mechanism you can easily augument the behaviour of\nSnabbdom. For demonstration take a look at the implementations of the\ndefault modules.\n\n## Modules documentation\n\nThis describes the core modules. All modules are optional.\n\n### The class module\n\nThe class module provides an easy way to dynamically toggle classes on\nelements. It expects an object in the `class` data property. The object should\nmap class names to booleans that indicates whether or not the class should stay\nor go on the VNode.\n\n```javascript\nh('a', {class: {active: true, selected: false}}, 'Toggle');\n```\n\n### The props module\n\nAllows you to set properties on DOM elements.\n\n```javascript\nh('a', {props: {href: '/foo'}}, 'Go to Foo');\n```\n\n### The attributes module\n\nSame as props but set attributes instead of properties on DOM elements\n\n```javascript\nh('a', {attrs: {href: '/foo'}}, 'Go to Foo');\n```\n\nAttributes are added and updated using `setAttribute`. In case of an attribute \nthat has been previously added/set is no longer present in the `attrs` object, \nit is removed from the DOM element's attribute list using `removeAttribute`. \n\nIn the case of boolean attributes (.e.g. `disabled`, `hidden`, `selected` ...). \nThe meaning doesn't depend on the attribute value (`true` or `false`) but depends\ninstead on the presence/absence of the attribute itself in the DOM element. Those \nattributes are handled differently by the module : if a boolean attribute is set \nto a [falsy value](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean) (`0`, `-0`, `null`, `false`,`NaN`, `undefined`, or the empty \nstring (`\"\"`)) then the attribute will be removed from the attribute list of the\nDOM element.\n\n### The style module\n\nThe style module is for making your HTML look slick and animate smoothly. At\nit's core it allows you to set CSS properties on elements.\n\n```javascript\nh('span', {\n  style: {border: '1px solid #bada55', color: '#c0ffee', fontWeight: 'bold'}\n}, 'Say my name, and every colour illuminates');\n```\n\nNote that the style module does not remove style attributes if they are removed\nas properties from the style object. To remove a style you should instead set\nit to the empty string.\n\n```javascript\nh('div', {\n  style: {position: shouldFollow ? 'fixed' : ''}\n}, 'I, I follow, I follow you');\n```\n\n#### Delayed properties\n\nYou can specify properties as being delayed. Whenever these properties change\nthe change is not applied until after the next frame.\n\n```javascript\nh('span', {\n  style: {opacity: '0', transition: 'opacity 1s', delayed: {opacity: '1'}}\n}, 'Imma fade right in!');\n```\n\nThis makes it easy to declaratively animate the entry of elements.\n\n#### Set properties on `remove`\n\nStyles set in the `remove` property will take effect once the element is about\nto be moved from the DOM. The applied styles should be animated with CSS\ntransitions. Only once all the styles is done animating will the element be\nremoved from the DOM.\n\n```javascript\nh('span', {\n  style: {opacity: '1', transition: 'opacity 1s',\n          remove: {opacity: '0'}}\n}, 'It\\'s better to fade out than to burn away');\n```\n\nThis makes it easy to declaratively animate the removal of elements.\n\n#### Set properties on `destroy`\n\n```javascript\nh('span', {\n  style: {opacity: '1', transition: 'opacity 1s',\n          destroy: {opacity: '0'}}\n}, 'It\\'s better to fade out than to burn away');\n```\n\n### Eventlisteners module\n\nThe event listeners module gives powerful capabilities for attaching\nevent listeners.\n\nYou can attach a function to an event on a VNode by supplying an object at `on`\nwith a property corresponding to the name of the event you want to listen to.\nThe function will be called when the event happens and will be passed the event\nobject that belongs to it.\n\n```javascript\nfunction clickHandler(ev) { console.log('got clicked'); }\nh('div', {on: {click: clickHandler}});\n```\n\nVery often however you're not really interested in the event object itself.\nOften you have some data associated with the element that triggers an event\nand you want that data passed along instead.\n\nConsider a counter application with three buttons, one to increment the counter\nby 1, one to increment the counter by 2 and one to increment the counter by 3.\nYou're don't really care exactly which button was pressed. Instead you're\ninterested in what number was associated with the clicked button. The event listeners\nmodule allows one to express that by supplying an array at the named event property.\nThe first element in the array should be a function that will be invoked with\nthe value in the second element once the event occurs.\n\n```javascript\nfunction clickHandler(number) { console.log('button ' + number + ' was clicked!'); }\nh('div', [\n  h('a', {on: {click: [clickHandler, 1]}}),\n  h('a', {on: {click: [clickHandler, 2]}}),\n  h('a', {on: {click: [clickHandler, 3]}}),\n]);\n```\n\nSnabbdom allows swapping event handlers between renders. This happens without\nactually touching the event handlers attached to the DOM.\n\nNote, however, that **you should be careful when sharing event handlers between\nVNodes**, because of the technique this module uses to avoid re-binding\nevent handlers to the DOM. (And in general, sharing data between VNodes is\nnot guaranteed to work, because modules are allowed to mutate the given data).\n\nIn particular, you should **not** do something like this:\n\n```javascript\n// Does not work\nvar sharedHandler = {\n  change: function(e){ console.log('you chose: ' + e.target.value); }\n};\nh('div', [\n  h('input', {props: {type: 'radio', name: 'test', value: '0'}, \n              on: sharedHandler}),\n  h('input', {props: {type: 'radio', name: 'test', value: '1'}, \n              on: sharedHandler}),\n  h('input', {props: {type: 'radio', name: 'test', value: '2'}, \n              on: sharedHandler})\n]);\n```\n\nFor many such cases, you can use array-based handlers instead (described above).\nAlternatively, simply make sure each node is passed unique `on` values:\n\n```javascript\n// Works\nvar sharedHandler = function(e){ console.log('you chose: ' + e.target.value); };\nh('div', [\n  h('input', {props: {type: 'radio', name: 'test', value: '0'}, \n              on: {change: sharedHandler}}),\n  h('input', {props: {type: 'radio', name: 'test', value: '1'}, \n              on: {change: sharedHandler}}),\n  h('input', {props: {type: 'radio', name: 'test', value: '2'}, \n              on: {change: sharedHandler}})\n]);\n```\n\n## Helpers\n\n### SVG\n\nSVG just works when using the `h` function for creating virtual\nnodes. SVG elements are automatially created with the appropriate\nnamespaces.\n\n```javascript\nvar vnode = h('div', [\n  h('svg', {attrs: {width: 100, height: 100}}, [\n    h('circle', {attrs: {cx: 50, cy: 50, r: 40, stroke: 'green', 'stroke-width': 4, fill: 'yellow'}})\n  ])\n]);\n```\n\nSee also the [SVG example](./examples/svg).\n\n### Thunks\n\nThe `thunk` function takes a name for identifying a thunk, a function that\nreturns a vnode and a variable amount of state parameters. If invoked the\nrender function will recieve the state parameters.\n\n`thunk(uniqueName, renderFn, [stateAguments])`\n\nThunks is an optimization strategy that can be used when one is dealing with\nimmutable data.\n\nConsider a simple function for creating a virtual node based on a number.\n\n```js\nfunction numberView(n) {\n  return h('div', 'Number is: ' + n);\n}\n```\n\nThe view depends only on `n`. This means that if `n` is unchanged then\ncreating the virtual DOM node and patching it against the old vnode is\nwasteful. To avoid the overhead we can use the `thunk` helper function.\n\n```js\nfunction render(state) {\n  return thunk('num', numberView, state.number);\n}\n```\n\nInstead of actually invoking the `numberView` function this will only place\na dummy vnode in the virtual tree. When Snabbdom patches this dummy vnode\nagainst a previous vnode it will compare the value of `n`. If `n` is unchanged\nit will simply reuse the old vnode. This avoids recreating the number view and\nthe diff process altogether.\n\nThe view function here is only an example. In practice thunks are only\nrelevant if you are rendering a complicated view that takes a significant\ncomputation time to generate.\n\n",
  "readmeFilename": "README.md",
  "_id": "snabbdom@0.3.1",
  "_from": "snabbdom@0.3.1"
}
