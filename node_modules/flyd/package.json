{
  "name": "flyd",
  "version": "0.2.2",
  "description": "The less is more, modular, functional reactive programming library",
  "main": "lib/index.js",
  "directories": {
    "example": "examples",
    "test": "test"
  },
  "dependencies": {
    "ramda": "^0.19.1"
  },
  "devDependencies": {
    "benchmark": "^1.0.0",
    "bluebird": "^2.9.13",
    "browserify": "^10.2.4",
    "coveralls": "^2.11.2",
    "eslint": "^1.10.3",
    "istanbul": "^0.3.15",
    "mocha": "^2.2.1",
    "mocha-lcov-reporter": "0.0.2",
    "transducers.js": "0.3.x"
  },
  "scripts": {
    "test-lib": "mocha",
    "test": "eslint lib/ test/ module/ && mocha -R dot test/*.js module/**/test/*.js",
    "docs": "documentation -f md lib/index.js > API.md",
    "perf": "./perf/run-benchmarks",
    "post-to-coveralls-io": "istanbul cover _mocha --report lcovonly -- -R spec && cat ./coverage/lcov.info | coveralls && rm -rf ./coverage",
    "build": "browserify -s flyd lib/index.js > flyd.js"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/paldepind/flyd.git"
  },
  "keywords": [
    "functional",
    "reactive",
    "modular",
    "library"
  ],
  "author": {
    "name": "Simon Friis Vindum"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/paldepind/flyd/issues"
  },
  "homepage": "https://github.com/paldepind/flyd",
  "testling": {
    "harness": "mocha",
    "files": "test/*.js",
    "browsers": [
      "ie/8..latest",
      "firefox/16..latest",
      "firefox/nightly",
      "chrome/22..latest",
      "chrome/canary",
      "opera/12..latest",
      "opera/next",
      "safari/5.1..latest",
      "ipad/6.0..latest",
      "iphone/6.0..latest",
      "android-browser/4.2..latest"
    ]
  },
  "readme": "# Flyd\n\nThe modular, KISS, functional reactive programming library for JavaScript.\n\n[![Build Status](https://travis-ci.org/paldepind/flyd.svg?branch=master)](https://travis-ci.org/paldepind/flyd)\n[![Coverage Status](https://coveralls.io/repos/paldepind/flyd/badge.svg?branch=master)](https://coveralls.io/r/paldepind/flyd?branch=master)\n[![Join the chat at https://gitter.im/paldepind/flyd](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/paldepind/flyd?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\n# Table of contents\n\n* [Introduction](#introduction)\n* [Features](#features)\n* [Examples](#examples)\n* [Tutorial](#tutorial)\n* [API](#api)\n* [Modules](#modules)\n* [Misc](#misc)\n\n## Introduction\n\nFunctional reactive programming is a powerful programming paradigm for\nexpressing values that change over time. But existing libraries for JavaScript\nare huge, complex, have a high learning curve and aren't functional enough.\n\nFlyd is simple and expressive. It has a minimal but powerful core on top of\nwhich new abstractions can be built modularly.\n\n## Features\n\n__Main features__\n\n* __Simple but powerful__. Less is more! Flyd provides combinable observable\n  streams as the basic building block. This minimal core is less than 200 SLOC\n  which makes the library transparent â€“ end users can realistically get a full\n  understanding of how the library works.\n* __More functional in style__. Flyd is more functional than existing FRP\n  libraries. Instead of methods it gives you curried functions with arguments\n  in the order suitable for partial application. This gives more expressive\n  power and modularity.\n* __Modularity__. The core of the Flyd is powerful and documented. This makes\n  it easy for users of the library to create new FRP abstractions if existing ones\n  do not exist. This in turn makes it viable to capture more patterns than\n  otherwise because they can exist as separate modules. [List of existing modules](#modules).\n\n__Other features__\n\n* Supports the transducer protocol. You can for instance transduce streams with\n  [Ramda](http://ramdajs.com/) and [transducers.js](https://github.com/jlongster/transducers.js).\n* Complies to the [fantasy land](https://github.com/fantasyland/fantasy-land)\n  applicative specification.\n* [Elegant support for promises](#using-promises-for-asynchronous-operations).\n* [Atomic updates](#atomic-updates).\n\n## Examples\n\n* [Sum](http://paldepind.github.io/flyd/examples/sum/) - A very simple example\n* [Multiple clicks](http://paldepind.github.io/flyd/examples/multiple-clicks/) - A remake\n  of the multiple clicks example from \"The introduction to Reactive\n  Programming you've been missing\". Compare it to this [RxJs\n  implementation](http://jsfiddle.net/ksj51q5k/).\n* [Secret combination](http://paldepind.github.io/flyd/examples/secret-combination/)\n* [Ramda transducer](https://github.com/paldepind/flyd/tree/master/examples/ramda-transducer)\n* [Who to follow](http://paldepind.github.io/flyd/examples/who-to-follow/)\n\nFor other examples check the source code of the [modules](#modules).\n\n## Tutorial\n\nThis is not general introduction to functional reactive programming. For that take\na look at [The introduction to Reactive Programming you've been\nmissing](https://gist.github.com/staltz/868e7e9bc2a7b8c1f754) and/or [this Elm\ntutorial](http://elm-lang.org/learn/Using-Signals.elm) if you are comfortable\nwith reading Haskell-like code.\n\nThis is not a demonstration of how you would write code with Flyd on a day to\nday basis. For that take a look at the [examples](#examples).\n\nThis tutorial will however introduce you to the minimal but powerful core that\nFlyd provides and show you how it can be used to build FRP abstractions.\n\n### Creating streams\n\nFlyd gives you streams as the building block for creating reactive dataflows.\nThey serve the same purpose as what other FRP libraries call Signals, Observables,\nProperties and EventEmitters.\n\nThe function `flyd.stream` creates a representation of a value that changes\nover time. The resulting stream is a function. At first sight it works a bit\nlike a getter-setter:\n\n```javascript\n// Create a stream with initial value 5.\nvar number = flyd.stream(5);\n// Get the current value of the stream.\nconsole.log(number()); // logs 5\n// Update the value of the stream.\nconsole.log(number(7));\n// The stream now returns the new value.\nconsole.log(number()); // logs 7\n```\n\nTop level streams, that is streams without dependencies, should typically\ndepend on the external world, like user input or fetched data.\n\nSince streams are just functions you can easily plug them in whenever a\nfunction is expected.\n\n```javascript\nvar clicks = flyd.stream();\ndocument.getElementById('button').addEventListener('click', clicks);\nvar messages = flyd.stream();\nwebSocket.onmessage = messages;\n```\n\nClicks events will now flow down the `clicks` stream and WebSockets messages\ndown the `messages` stream.\n\n### Dependent streams\n\nStreams can depend on other streams. Use `var combined = flyd.combine(combineFn, [a, b, c, ...])`.\nThe `combineFn` function will be called as `(a, b, c, ..., self, changed) => v`,\nwhere `a, b, c, ...` is a spread of each dependency, `self` is a reference to the\ncombine stream itself, and `changed` is an array of streams that were atomically\nupdated.\n\nFlyd automatically updates the stream whenever a dependency changes.  This\nmeans that the `sum` function below will be called whenever `x` and `y`\nchanges.  You can think of dependent stream as streams that automatically\nlistens to or subscribes to their dependencies.\n\n```javascript\n// Create two streams of numbers\nvar x = flyd.stream(4);\nvar y = flyd.stream(6);\n// Create a stream that depends on the two previous streams\n// and with its value given by the two added together.\nvar sum = flyd.combine(function(x, y) {\n  return x() + y();\n}, [x, y]);\n// `sum` is automatically recalculated whenever the streams it depends on changes.\nx(12);\nconsole.log(sum()); // logs 18\ny(8);\nconsole.log(sum()); // logs 20\n```\n\nNaturally, a stream with dependencies can depend on other streams with dependencies.\n\n```javascript\n// Create two streams of numbers\nvar x = flyd.stream(4);\nvar y = flyd.stream(6);\nvar squareX = flyd.combine(function(x) {\n  return x() * x();\n}, [x]);\nvar squareXPlusY = flyd.combine(function(y, squareX) {\n  return y() + squareX();\n}, [y, squareX]);\nconsole.log(squareXPlusY()); // logs 22\nx(2);\nconsole.log(squareXPlusY()); // logs 10\n```\n\nThe body of a dependent stream is called with the spread of: each dependency, itself, and a list\nof the dependencies that have changed since its last invocation (due to [atomic\nupdates](#atomic-updates) several streams could have changed).\n\n```javascript\n// Create two streams of numbers\nvar x = flyd.stream(1);\nvar y = flyd.stream(2);\nvar sum = flyd.combine(function(x, y, self, changed) {\n  // The stream can read from itself\n  console.log('Last sum was ' + self());\n  // On the initial call no streams has changed and `changed` will be []\n  changed.map(function(s) {\n    var changedName = (s === y ? 'y' : 'x');\n    console.log(changedName + ' changed to ' + s());\n  });\n  return x() + y();\n}, [x, y]);\n```\n\n*Note* Returning `undefined` in the `combineFn` will not trigger an update\nto the stream. To trigger on undefined, update directly:\n```\nflyd.combine((_, self, changed) => { self(undefined); }, [depStream]);\n```\n\n### Using callback APIs for asynchronous operations\n\nInstead of returning a value a stream can update itself by calling itself. This\nis handy when working with APIs that takes callbacks.\n\n```javascript\nvar urls = flyd.stream('/something.json');\nvar responses = flyd.combine(function(urls, self) {\n  makeRequest(urls(), self);\n}, [urls]);\nflyd.combine(function(responses) {\n  console.log('Received response!');\n  console.log(responses());\n}, [responses]);\n```\n\nNote that the stream that logs the responses from the server should only be called\nafter an actual response has been received (otherwise `responses()` would return\n`undefined`). Fortunately a stream's body will not be called before all of its declared\nstreams has received a value (this behaviour can be circumvented with\n[flyd.immediate](#flydimmediatestream)).\n\n### Using promises for asynchronous operations\n\nFlyd has inbuilt support for promises. Similarly to how a promise can never be\nresolved with a promise, a promise can never flow down a stream. Instead the\nfulfilled value of the promise will be sent down the stream.\n\n```javascript\nvar urls = flyd.stream('/something.json');\nvar responses = flyd.stream(requestPromise(urls()));\nflyd.on(function(responses) {\n  console.log('Received response!');\n  console.log(responses());\n}, responses);\n```\n\n### Mapping over a stream\n\nYou've now seen most of the basic building block which Flyd provides. Let's see\nwhat we can do with them. Let's write a function that takes a function and a\nstream and returns a new stream with the function applied to every value\nemitted by the stream. In short, a `map` function.\n\n```javascript\nvar mapStream = function(f, s) {\n  return flyd.combine(function(s) {\n    return f(s());\n  }, [s]);\n};\n```\n\nWe simply create a new stream dependent on the first stream. We declare\nthe stream as a dependency so that our stream won't return values before\nthe original stream produces its first value.\n\nFlyd includes a similar `map` function as part of its core.\n\n### Scanning a stream\n\nLets try something else: a scan function for accumulating a stream! It could\nlook like this:\n\n```javascript\nvar scanStream = function(f, acc, s) {\n  return flyd.combine(function(s) {\n    acc = f(acc, s());\n    return acc;\n  }, [s]);\n};\n```\n\nOur scan function takes an accumulator function, an initial value and a stream.\nEvery time the original stream emits a value we pass it to the accumulator\nfunction along with the accumulated value.\n\nFlyd includes a `scan` function as part of its core.\n\n### Stream endings\n\nWhen you create a stream with `flyd.stream` it will have an `end` property\nwhich is also a stream. That is an _end stream_:\n\n```javascript\nvar s = flyd.stream();\nconsole.log(flyd.isStream(s.end)); // logs `true`\n```\n\nYou can end a stream by pushing `true` into its end stream:\n\n```javascript\nvar s = flyd.stream();\ns.end(true); // this ends `s`\n```\n\nWhen you create a dependent stream its end stream will initially depend on all\nthe end streams of its dependencies:\n\n```javascript\nvar n1 = flyd.stream();\nvar n2 = flyd.stream();\nvar sum = flyd.combine(function(n1, n2) {\n  return n1() + n2();\n}, [n1, n2]);\n```\n\n`sum.end` now depends on `n1.end` and `n2.end`. This means that whenever one of\nthe `sum`s dependencies end `sum` will end as well.\n\nYou can change what a stream's end stream depends on with `flyd.endsOn`:\n\n```javascript\nvar number = flyd.stream(2);\nvar killer = flyd.stream();\nvar square = flyd.endsOn(flyd.merge(number.end, killer), flyd.combine(function(number) {\n  return number() * number();\n}, [number]));\n```\n\nNow `square` will end if either `number` ends or if `killer` emits a value.\n\nThe fact that a stream's ending is itself a stream is a very powerful concept.\nIt means that we can use the full expressiveness of Flyd to control when a stream\nends. For an example, take a look at the implementation of\n[`takeUntil`](https://github.com/paldepind/flyd-takeuntil).\n\n### Fin\n\nYou're done! To learn more check out the [API](#api), the [examples](#examples)\nand the source of the [modules](#modules).\n\n## API\n\n### flyd.stream()\n\nCreates a new top level stream.\n\n__Signature__\n\n`a -> Stream a`\n\n__Example__\n```javascript\nvar n = flyd.stream(1); // Stream with initial value `1`\nvar s = flyd.stream(); // Stream with no initial value\n```\n\n### flyd.combine(body, dependencies)\n\nCreates a new dependent stream.\n\n__Signature__\n\n`(...Stream * -> Stream b -> b) -> [Stream *] -> Stream b`\n\n__Example__\n```javascript\nvar n1 = flyd.stream(0);\nvar n2 = flyd.stream(0);\nvar max = flyd.combine(function(n1, n2, self, changed) {\n  return n1() > n2() ? n1() : n2();\n}, [n1, n2]);\n```\n\n###flyd.isStream(stream)\n\nReturns `true` if the supplied argument is a Flyd stream and `false` otherwise.\n\n__Signature__\n\n`* -> Boolean`\n\n__Example__\n\n```javascript\nvar s = flyd.stream(1);\nvar n = 1;\nflyd.isStream(s); //=> true\nflyd.isStream(n); //=> false\n```\n\n###flyd.immediate(stream)\n\nBy default the body of a dependent stream is only called when all the streams\nupon which it depends has a value. `immediate` can circumvent this behaviour.\nIt immediately invokes the body of a dependent stream.\n\n__Signature__\n\n`Stream a -> Stream a`\n\n__Example__\n\n```javascript\nvar s = flyd.stream();\nvar hasItems = flyd.immediate(flyd.combine(function(s) {\n  return s() !== undefined && s().length > 0;\n}, [s]);\nconsole.log(hasItems()); // logs `false`. Had `immediate` not been\n                         // used `hasItems()` would've returned `undefined`\ns([1]);\nconsole.log(hasItems()); // logs `true`.\ns([]);\nconsole.log(hasItems()); // logs `false`.\n```\n\n###flyd.endsOn(endStream, s)\n\nChanges which `endsStream` should trigger the ending of `s`.\n\n__Signature__\n\n`Stream a -> Stream b -> Stream b`\n\n__Example__\n\n```javascript\nvar n = flyd.stream(1);\nvar killer = flyd.stream();\n// `double` ends when `n` ends or when `killer` emits any value\nvar double = flyd.endsOn(flyd.merge(n.end, killer), flyd.combine(function(n) {\n  return 2 * n();\n}, [n]);\n```\n\n###flyd.map(fn, s)\n\nReturns a new stream consisting of every value from `s` passed through `fn`. I.e. `map` creates\na new stream that listens to `s` and applies `fn` to every new value.\n\n__Signature__\n\n`(a -> result) -> Stream a -> Stream result`\n\n__Example__\n```javascript\nvar numbers = flyd.stream(0);\nvar squaredNumbers = flyd.map(function(n) { return n*n; }, numbers);\n```\n\n###flyd.on(fn, s)\n\nSimilar to `map` except that the returned stream is empty. Use `on` for doing\nside effects in reaction to stream changes. Use the returned stream only if you\nneed to manually end it.\n\n__Signature__\n\n`(a -> result) -> Stream a -> Stream undefined`\n\n__Example__\n```javascript\nvar numbers = flyd.stream(0);\nflyd.on(function(n) { console.log('numbers changed to', n); }, numbers);\n```\n\n###flyd.scan(fn, acc, stream)\n\nCreates a new stream with the results of calling the function on every incoming\nstream with and accumulator and the incoming value.\n\n__Signature__\n\n`(a -> b -> a) -> a -> Stream b -> Stream a`\n\n__Example__\n```javascript\nvar numbers = flyd.stream();\nvar sum = flyd.scan(function(sum, n) { return sum+n; }, 0, numbers);\nnumbers(2)(3)(5);\nsum(); // 10\n```\n\n###flyd.merge(stream1, stream2)\n\nCreates a new stream down which all values from both `stream1` and `stream2`\nwill be sent.\n\n__Signature__\n\n`Stream a -> Stream a -> Stream a`\n\n__Example__\n```javascript\nvar btn1Clicks = flyd.stream();\nbutton1Elm.addEventListener(btn1Clicks);\nvar btn2Clicks = flyd.stream();\nbutton2Elm.addEventListener(btn2Clicks);\nvar allClicks = flyd.merge(btn1Clicks, btn2Clicks);\n```\n\n### flyd.transduce(transducer, stream)\n\nCreates a new stream resulting from applying `transducer` to `stream`.\n\n__Signature__\n\n`Transducer -> Stream a -> Stream b`\n\n__Example__\n\n```javascript\nvar t = require('transducers.js');\n\nvar results = [];\nvar s1 = flyd.stream();\nvar tx = t.compose(\n  t.map(function(x) { return x * 2; }),\n  t.dedupe()\n);\nvar s2 = flyd.transduce(tx, s1);\nflyd.combine(function(s2) { results.push(s2()); }, [s2]);\ns1(1)(1)(2)(3)(3)(3)(4);\nresults; // [2, 4, 6, 8]\n```\n\n###flyd.curryN(n, fn)\n\nReturns `fn` curried to `n`. Use this function to curry functions exposed by\nmodules for Flyd.\n\n__Signature__\n\n`Integer -> (* -> a) -> (* -> a)`\n\n__Example__\n\n```javascript\nfunction add(x, y) { return x + y; };\nflyd.curryN(2, add);\nvar add\n```\n\n###stream()\n\nReturns the last value of the stream.\n\n__Signature__\n\n`a`\n\n__Example__\n\n```javascript\nvar names = flyd.stream('Turing');\nnames(); // 'Turing'\n```\n\n###stream(val)\n\nPushes a value down the stream.\n\n__Signature__\n\n`a -> Stream a`\n\n__Example__\n\n```javascript\nnames('Bohr');\nnames(); // 'Bohr'\n```\n\n###stream.end\n\nA stream that emits `true` when the stream ends. If `true` is pushed down the\nstream the parent stream ends.\n\n###stream.map(f)\n\nReturns a new stream identical to the original except every\nvalue will be passed through `f`.\n\n_Note:_ This function is included in order to support the fantasy land\nspecification.\n\n__Signature__\n\nCalled bound to `Stream a`: `(a -> b) -> Stream b`\n\n__Example__\n\n```javascript\nvar numbers = flyd.stream(0);\nvar squaredNumbers = numbers.map(function(n) { return n*n; });\n```\n\n###stream1.ap(stream2)\n\n`stream1` must be a stream of functions.\n\nReturns a new stream which is the result of applying the\nfunctions from `stream1` to the values in `stream2`.\n\n_Note:_ This function is included in order to support the fantasy land\nspecification.\n\n__Signature__\n\nCalled bound to `Stream (a -> b)`: `a -> Stream b`\n\n__Example__\n\n```javascript\nvar add = flyd.curryN(2, function(x, y) { return x + y; });\nvar numbers1 = flyd.stream();\nvar numbers2 = flyd.stream();\nvar addToNumbers1 = flyd.map(add, numbers1);\nvar added = addToNumbers1.ap(numbers2);\n```\n\n###stream.of(value)\n\nReturns a new stream with `value` as its initial value. It is identical to\ncalling `flyd.stream` with one argument.\n\n__Signature__\n\nCalled bound to `Stream (a)`: `b -> Stream b`\n\n__Example__\n```javascript\nvar n = flyd.stream(1);\nvar m = n.of(1);\n```\n\n### Modules\n\nIf you're created a module for Flyd open an issue or send a pull request and it\nwill be added to this list.\n\n* [flyd/module/filter](module/filter) â€“ Filter values from stream based on predicate.\n* [flyd/module/lift](module/lift) â€“ Maps a function taking _n_ parameters over _n_ streams.\n* [flyd/module/flatmap](module/flatmap) â€“ Maps a function over a stream of streams and flattens the result to a single stream.\n* [flyd/module/switchlatest](module/switchlatest) â€“ Flattens a stream of streams. The result stream reflects changes from the last stream only.\n* [flyd/module/keepwhen](module/keepwhen) â€“ Keep values from one stream only when another stream is true.\n* [flyd/module/obj](module/obj) â€“ Functions for working with stream in objects.\n* [flyd/module/sampleon](module/sampleon) â€“ Samples from a stream every time an event occurs on another stream.\n* [flyd/module/scanmerge](module/scanmerge) â€“ Merge and scan several streams into one.\n* [flyd/module/mergeall](module/mergeall) â€“ Merge a list of streams.\n* [flyd/module/takeuntil](module/takeuntil) â€“ Emit values from a stream until a second stream emits a value.\n* [flyd/module/forwardto](module/forwardto) â€“ Create a new stream that passes all values through a function and forwards them to a target stream.\n* [flyd-cacheUntil](https://github.com/ThomWright/flyd-cacheUntil) â€“ Cache a stream's output until triggered by another stream.\n* [flyd/module/droprepeats](module/droprepeats) â€“ Drop repeated values from a stream.\n* [flyd-keyboard](https://github.com/raine/flyd-keyboard) â€“ Keyboard events as streams.\n* [flyd-glob](https://github.com/StreetStrider/flyd-glob) â€“ File glob and watch for Flyd.\n* Time related\n  * [flyd/module/every](module/every) â€“ Takes a number of milliseconds t and creates a stream of the current time updated every t.\n  * [flyd/module/aftersilence](module/aftersilence) â€“ Buffers values from a source stream in an array and emits it after a specified duration of silence from the source stream.\n  * [flyd/module/inlast](module/inlast) â€“ Creates a stream that emits a list of all values from the source stream that were emitted in a specified duration.\n  * [flyd-onAnimationFrame](https://github.com/ThomWright/flyd-onAnimationFrame) â€“ Emits values from a source stream on successive animation frames.\n  * [flyd-timeInterval](https://github.com/ThomWright/flyd-timeInterval) â€“ Records the time interval between consecutive values emitted from a stream.\n\n## Misc\n\n### The name\n\nThe name Flyd was chosen since the author of Flyd is danish and Flyd is a\ndanish word meaning float, afloat or flow. It is furthermore short and not too\nbad for searching.\n\nFor most native English speakers \"flyd\" is impossible to pronounce like a\ndane would do it. The \"d\" is soft like \"th\" in \"the\". The \"y\" is a vocal sound\nunknown to the English language. [If you're curious Google Translates listening feature\nprovides an accurate pronounciation.](https://translate.google.com/#da/en/flyd).\n\n### Atomic updates\n\nConsider the following example:\n\n```javascript\nvar a = flyd.stream(1);\nvar b = flyd.combine(function(a) { return a() * 2; }, [a]);\nvar c = flyd.combine(function(a) { return a() + 4; }, [a]);\nvar d = flyd.combine(function(b, c, self, ch) {\n  result.push(b() + c());\n}, [b, c]);\n```\n\nThe dependency graph looks like this.\n\n```\n    a\n  /   \\\n b     c\n  \\   /\n    d\n```\n\nNow, when a value flows down `a`, both `b` and `c` will change because they\ndepend on `a`. If you merely consider streams as being event emitters you'd expect `d`\nto be updated twice. Because `a` triggers `b` triggers `d` after which `a` also\ntriggers `c` which _again_ triggers `d`.\n\nBut Flyd handles such cases optimally. Since only one value entered the\nsystem `d` will only be updated once with the changed values of `b` and `c`.\n\nFlyd guarantees that when a single value enters the system every stream will\nonly be updated once, along with their dependencies in their most recent state.\n\nThis avoids superfluous updates of your streams and intermediate states when\nseveral streams change at the same time.\n\nFlyd implements atomic updates with a _O(n)_ topological sort where _n_\nis number of streams that directly or indirectly depends on the updated\nstream. \n\n### Environment support\n\nFlyd works in all ECMAScript 5 environments. It works in older environments\nwith polyfills for `Array.prototype.filter` and `Array.prototype.map`.\n\n### Run tests, generate documentation\n\nTo run the test, clone this repository and:\n\n```bash\nnpm install\nnpm test\n```\n\nThe `npm test` command run three tests: a eslint js style checker test, the test of the core library and the test of the modules. If you want to run only the test of the library `npm run test`.\n\nThe API.md file is generated using `npm run docs` (it assumes it has documentation installed globally: `npm i -g documentation`)\n\n\n\n\n\n",
  "readmeFilename": "README.md",
  "_id": "flyd@0.2.2",
  "dist": {
    "shasum": "6ec2fda4411327710d2f484c53bffc6b8ae6ca7c"
  },
  "_from": "flyd@",
  "_resolved": "https://registry.npmjs.org/flyd/-/flyd-0.2.2.tgz"
}
